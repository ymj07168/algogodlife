## 교재 5장 재귀 알고리즘

### 재귀 알고리즘의 기본
* __재귀(recursion)__ : 자기 자신을 포함하고 다시 자기 자신을 사용하여 정의되는 경우
* __팩토리얼(factorial)__
  ```python
  # 양의 정수 n의 팩토리얼 구하기
  def factorial(n: int) -> int:
      if n > 0:
          return n * factorial(n-1)
      else:
          return 1
        
  # 파이썬은 표준 라이브러리로 math 모듈에서 factorial() 함수 제공 => math.factorial(x)
  ```
* __재귀 호출(recursive call)__ : 자신과 똑같은 함수를 호출하는 것
* __직접 재귀와 간접 재귀__ 
  - 직접(direct) 재귀 : 자신과 똑같은 함수를 호출하는 방식
  - 간접(indirect) 재귀 : a() 함수가 b() 함수를 호출하고 다시 b() 함수가 a() 함수를 호출하는 구조
* __유클리드 호제법__
  - 두 정숫값의 최대 공약수를 구하는 문제
  - 직사각형 안을 정사각형 여러 개로 가득 채워나갈 때, 이렇게 만들 수 있는 정사각형 가운데 가장 작은 정사각형의 변의 길이
  ```python
  # 유클리드 호제법으로 최대 공약수 구하기
  def gcd(x: int, y: int) -> int:
      if y == 0:
          return x
      else:
          return gcd(y, x % y)
  
  # 파이썬은 표준 라이브러리로 math 모듈에서 gcd() 함수 제공 => math.gcd(x)
  ```
  
### 재귀 알고리즘의 분석
* __하향식 분석과 상향식 분석__
  - 하향식 분석 : 가장 위쪽에 위치한 상자의 함수 호출부터 시작하여 계단식으로 조사해나가는 분석 방법
  - 상향식 분석 : 아래쪽부터 쌓아 올리며 분석하는 방법
* 재귀 알고리즘의 비재귀적 표현
  ```pyhton
  # 순수한 재귀 함수 구현
  def recur(n: int) -> int:
      if n > 0:
      recur(n-1)
      print(n)
      recur(n-2)
  
  # 스택 사용과 꼬리 재귀 제거로 비재귀적으로 구현
  from stack import Stack
  
  def recur(n: int) -> int
      s = Stack(n)
      
      while True:
          if n > 0:
              s.push(n)
              n = n - 1
              continue
          if not s.is_empty():
              n = s.pop()
              print(n)
              n = n - 2
              continue
          break
  ```
  
### 하노이의 탑
  ```python
  # 하노이의 탑 구현하기
  
  def move(no: int, x: int, y: int) -> None:
        """원반 no개를 x기둥에서 y기둥으로 옮김"""
        """중간 기둥 6-x-y"""
        if no > 1:
          move(no-1, x, 6-x-y)
        
        printf(f'원반 [{no}]을(를) {x}기둥에서 {y}기둥으로 옮깁니다.')
      
        if no > 1:
          move(no-1, 6-x-y, y)

  print('하노이의 탑을 구현합니다.')
  n = int(input('원반의 개수를 입력하세요.:'))

  move(n,1,3) # 1기둥에 쌓인 원반 n개를 3기둥으로 옮김
  ```
  - move 함수
    1. 바닥에 있는 원반 제외한 그룹을 1기둥에서 2기둥으로 옮김
    2. 바닥에 있는 원반[no]를 1기둥에서 3기둥으로 옮겼다는 것을 출력
    3. 바닥에 있는 원반을 제외한 그룹을 2기둥에서 3기둥으로 옮김

### 8퀸 문제
  * 8개의 퀸이 서로 공격하여 잡을 수 없도록 8 * 8 체스판에 배치하는 문제
  * __분기 작업(branching)__ : 가지가 뻗어나가듯이 배치 조합을 열거하는 방법
  * __분할 정복법(divide and conquer)__ : 큰 문제를 작은 문제로 분할하고, 작은 문제 풀이법을 결합하여 전체 풀이법을 얻는 방법
  * __한정 작업(bounding)__ : 필요하지 않은 분기를 없애서 불필요한 조합을 열거하지 않는 방법
  ```python
  # 8퀸 문제 알고리즘 구현하기
  
  pos = [0] * 8
  flag_a = [False] * 8
  flag_b = [False] * 15
  flag_c = [False] * 15
  
  def put() -> None:
      for i in range(8):
          print(f'{pos[i]:2}', end='')
      print()
  
  def set(i: int) -> None:
      for j in range(8):
          if( not flag_a[j] and not flag_b[i+j] and not flag_c[i-j+7]:
              pos[i] = j
              if i == 7:
                  put()
              else:
                  flag_a[j] = flag_b[i+j] = flag_c[i-j+7] = True
                  set(i+1)
                  flag_a[j] = flag_b[i+j] = flag_c[i-j+7] = False
  set(0)
  ```
  ---
  
## 백준 문제
* lambda는 매우 편리하다
  - words.sort(key=lambda x : (len(x), x))
* set 함수로 리스트의 중복되는 값 제거 가능
  - list(set(words)
* 인덱스를 뽑아낼 때, index 함수 vs dic
  - for i in x_list:  
    dic = {sort_list[i]: i for i in range(len(sort_list))}
  - for i in x_list:  
    sort_list.index(i)  
